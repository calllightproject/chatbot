<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>
    {% if nurse_context|default(false) %}
      My Rooms — {{ nurse_name|default('') }}
    {% else %}
      Real-Time Request Dashboard
    {% endif %}
  </title>
  <style>
    :root {
      --core-blue: #00205b;
      --accent-blue: #007eb4;
      --neutral-gray-text: #303235;
      --light-gray-background: #f5f5f5;
      --white: #ffffff;
      --border:#e5e7eb;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      padding: 20px;
      background-color: var(--light-gray-background);
      color: var(--neutral-gray-text);
    }
    .dashboard-container {
      max-width: 980px;
      margin: 20px auto;
      background: white;
      padding: 20px;
      border-radius: 12px;
      border:1px solid var(--border);
      box-shadow: 0 8px 20px rgba(0,0,0,0.06);
    }
    .header {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: start;
      margin-bottom: 12px;
    }
    h1 { color: var(--core-blue); margin: 0 0 6px 0; font-size: 1.5rem; }
    .subline { margin: 0 0 8px 0; font-size: 0.95rem; color: #555; }
    .chip-row { display:flex; flex-wrap:wrap; gap:6px; margin: 6px 0 0 0; }
    .chip { padding:6px 10px; border-radius:9999px; background:#eef2f7; border:1px solid #d7dde6; font-size:.85rem; color:#334155; }

    .actions { display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-self:end; }
    .link-btn, .btn {
      display:inline-block; padding:8px 12px; border-radius:8px; text-decoration:none;
      border:1px solid var(--core-blue); background: var(--core-blue); color:#fff; font-size:.9rem;
      transition: background-color .2s ease; white-space:nowrap; cursor:pointer;
    }
    .link-btn:hover, .btn:hover { background:#093582; }
    .seg { display:inline-flex; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#fff; }
    .seg a {
      padding:8px 10px; text-decoration:none; color:#0f172a; background:#fff;
      border-right:1px solid var(--border); font-size:.9rem;
    }
    .seg a:last-child { border-right:none; }
    .seg a.active { background:#e6eef8; color:#0b2a6f; font-weight:600; }

    #requests-list { list-style:none; padding:0; margin:16px 0 0 0; }
    .request-item {
      display:flex; align-items:center; border:1px solid #ddd; padding:15px; margin-bottom:10px;
      border-radius:8px; background-color:#fff; gap:15px; transition: background-color .5s ease, opacity .3s ease;
    }
    .request-item.cna   { border-left: 6px solid var(--accent-blue); }
    .request-item.nurse { border-left: 6px solid #d43f27; }

    .request-item p { margin:0; font-size:1.05rem; flex-grow:1; }
    .meta { display:flex; gap:10px; align-items:center; white-space:nowrap; font-size:.9rem; color:#555; flex-wrap:wrap; }
    .role-span { font-size:.9rem; color:#555; }
    .timestamp { font-size:.9rem; color:#555; }

    .request-item button {
      padding:8px 12px; border:none; color:white; border-radius:6px; cursor:pointer; font-size:14px; transition:opacity .25s;
    }
    .ack-button    { background-color: #ffc107; color:#000; }
    .omw-button    { background-color: #28a745; }
    .asap-button   { background-color: #6f42c1; }
    .defer-btn     { background-color: #17a2b8; }
    .complete-btn  { background-color: #6c757d; }
    .request-item button:disabled { opacity:.5; cursor:not-allowed; }

    .status-new    { background-color: #eefcf1; }
    .status-warn   { background-color: #fff5dd; }
    .status-urgent { background-color: #fde8e8; }

    .toolbar { display:flex; align-items:center; gap:10px; margin-top:8px; }
    .muted { font-size:.85rem; color:#64748b; }
  </style>
</head>
<body>

  <div class="dashboard-container">
    <div class="header">
      <div>
        <h1>
          {% if nurse_context|default(false) %}
            My Rooms — {{ nurse_name|default('') }}
          {% else %}
            Real-Time Request Dashboard
          {% endif %}
        </h1>

        {% if nurse_context|default(false) %}
          {% set my_rooms = nurse_rooms|default([]) %}
          {% if my_rooms and my_rooms|length > 0 %}
            <div class="subline">Assigned rooms today:</div>
            <div class="chip-row">
              {% for r in my_rooms %}
                <span class="chip">{{ r }}</span>
              {% endfor %}
            </div>
          {% else %}
            <div class="subline">No rooms assigned yet for today.</div>
          {% endif %}
        {% endif %}

        <div class="toolbar">
          {% if nurse_context|default(false) %}
            <div class="seg" aria-label="Shift">
              <a href="{{ day_url }}"   class="{% if shift=='day' %}active{% endif %}">Day</a>
              <a href="{{ night_url }}" class="{% if shift=='night' %}active{% endif %}">Night</a>
            </div>
            <div class="seg" aria-label="Scope">
              <a href="{{ url_for('staff_dashboard_for_nurse', staff_name=nurse_name, shift=shift, scope='mine') }}" class="{% if scope=='mine' %}active{% endif %}">My Rooms</a>
              <a href="{{ url_for('staff_dashboard_for_nurse', staff_name=nurse_name, shift=shift, scope='all')  }}" class="{% if scope=='all'  %}active{% endif %}">All</a>
            </div>
          {% endif %}
          <button id="manual-refresh" class="btn" type="button">Refresh</button>
          <span class="muted" id="last-refresh"></span>
        </div>
      </div>

      <div class="actions">
        {% if nurse_context|default(false) %}
          <a class="link-btn" href="{{ url_for('dashboard') }}">Manager View</a>
        {% else %}
          <a class="link-btn" href="{{ url_for('staff_portal') }}">View My Rooms</a>
          <a class="link-btn" href="{{ url_for('analytics') }}">View Analytics</a>
        {% endif %}
      </div>
    </div>

    <ul id="requests-list">
      {% for request in active_requests|default([]) %}
        <li class="request-item {{ request.role|default('') }}"
            id="{{ request.id|default('') }}"
            data-id="{{ request.id|default('') }}"
            data-room="{{ request.room|default('') }}"
            data-request="{{ request.request|default('') }}"
            data-role="{{ request.role|default('') }}"
            data-timestamp="{{ request.timestamp|default('') }}"
            data-last-seen="{{ (request.timestamp|default('')) }}">
          <p>{{ request.request|default('') }}</p>
          <div class="meta">
            <span>Room: {{ request.room|default('—') }}</span>
            <span class="role-span">For: {{ request.role|default('')|upper }}</span>
            <span class="timestamp"></span>
            <span class="status-badge chip" style="display:none;"></span>
          </div>
          <button class="ack-button">Acknowledge</button>
          <button class="omw-button">On my way</button>
          <button class="asap-button">Be there ASAP</button>
          {% if request.role|default('') == 'cna' %}
            <button class="defer-btn">Defer to Nurse</button>
          {% endif %}
          <button class="complete-btn">Complete</button>
        </li>
      {% else %}
        <li class="request-item" style="justify-content:center">
          <p>No active requests.</p>
        </li>
      {% endfor %}
    </ul>
  </div>

  <!-- Context for JS -->
  <script>
    const NurseContext = {{ nurse_context|default(false)|tojson }};
    const NurseName    = {{ nurse_name|default('')|tojson }};
    const NurseShift   = {{ shift|default('day')|tojson }};
    const NurseScope   = {{ scope|default('all')|tojson }};
  </script>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script type="text/javascript">
    var socket = io();

    // Local caches
    const LocalStatus = new Map();        // request_id -> status
    const LocalStatusByKey = new Map();   // `${room}::${request_text}` -> status

    // ---- Helpers ----
    function normalizeText(s) { return (s || '').replace(/\s+/g, ' ').trim(); }
    function makeCompositeKey(room, text) {
      return `${(room || '').trim()}::${normalizeText(text)}`.toLowerCase();
    }
    function setStatusFor(id, room, text, status) {
      if (id) LocalStatus.set(id, status);
      const k = makeCompositeKey(room, text);
      if (k) LocalStatusByKey.set(k, status);
    }
    function getStatusFor(id, room, text) {
      if (id && LocalStatus.has(id)) return LocalStatus.get(id);
      const k = makeCompositeKey(room, text);
      if (k && LocalStatusByKey.has(k)) return LocalStatusByKey.get(k);
      return null;
    }

    let audioContext;
    function playNotificationSound() {
      try {
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') audioContext.resume();
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain); gain.connect(audioContext.destination);
        osc.type = 'sine'; osc.frequency.setValueAtTime(880, audioContext.currentTime);
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.5, audioContext.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + 0.5);
      } catch (_) {}
    }

    function updateAllTimersAndColors() {
      const items = document.querySelectorAll('#requests-list .request-item');
      const now = new Date();
      items.forEach(item => {
        const raw = item.dataset.timestamp || '';
        const ts = raw ? new Date(raw) : null;
        const minutes = ts ? Math.floor((now - ts) / 60000) : 0;

        const tsEl = item.querySelector('.timestamp');
        if (tsEl) tsEl.textContent = ts ? (minutes > 0 ? `${minutes}m ago` : 'Just now') : '';

        item.classList.remove('status-new', 'status-warn', 'status-urgent');
        if (ts) {
          if (minutes >= 10) item.classList.add('status-urgent');
          else if (minutes >= 5) item.classList.add('status-warn');
          else item.classList.add('status-new');
        }
      });
    }

    function buildRequestHTML(data) {
      const isCNA = (data.role || '') === 'cna';
      const deferBtn = isCNA ? '<button class="defer-btn">Defer to Nurse</button>' : '';
      return `
        <p>${(data.request || '')}</p>
        <div class="meta">
          <span>Room: ${(data.room || '—')}</span>
          <span class="role-span">For: ${(data.role || '').toUpperCase()}</span>
          <span class="timestamp"></span>
          <span class="status-badge chip" style="display:none;"></span>
        </div>
        <button class="ack-button">Acknowledge</button>
        <button class="omw-button">On my way</button>
        <button class="asap-button">Be there ASAP</button>
        ${deferBtn}
        <button class="complete-btn">Complete</button>
      `;
    }

    function applyLocalStatusToItem(li) {
      const id   = li?.dataset?.id;
      const room = li?.dataset?.room || '';
      const text = li?.dataset?.request || '';

      // Prefer DOM-pinned; fall back to memory maps
      let st = (li?.dataset?.localStatus || '').toLowerCase().trim();
      if (!st) st = getStatusFor(id, room, text);

      const ack = li.querySelector('.ack-button');
      const omw = li.querySelector('.omw-button');
      const asap = li.querySelector('.asap-button');
      const badge = li.querySelector('.status-badge');

      // Reset UI
      [ack, omw, asap].forEach(b => b && (b.disabled = false));
      if (badge) { badge.style.display = 'none'; badge.textContent = ''; }

      if (!st) return;

      if (st === 'ack') {
        if (ack) ack.disabled = true;
      } else if (st === 'omw') {
        if (ack) ack.disabled = true;
        if (omw) omw.disabled = true;
      } else if (st === 'asap') {
        if (ack) ack.disabled = true;
        if (asap) asap.disabled = true;
      } else if (st === 'completed') {
        [ack, omw, asap].forEach(b => b && (b.disabled = true));
        li.querySelector('.defer-btn')?.setAttribute('disabled', true);
        li.querySelector('.complete-btn')?.setAttribute('disabled', true);
      }

      if (badge) {
        const map = { ack:'Acknowledged', omw:'On my way', asap:'ASAP', deferred:'Deferred', completed:'Completed', pending:'Pending sync' };
        const label = map[st] || (li.dataset.pendingSync ? 'Pending sync' : '');
        if (label) { badge.textContent = label; badge.style.display = 'inline-flex'; }
      }
    }

    function upsertRequestItem(req) {
      const list = document.getElementById('requests-list');
      if (!list || !req) return;

      // Synthesize id if API didn't send one
      if (!req.id) req.id = 'key:' + makeCompositeKey(req.room, req.request);

      let li = document.getElementById(req.id);
      if (li) {
        // Update in place (keep node so DOM-pinned status survives)
        li.dataset.room = req.room || '';
        li.dataset.request = normalizeText(req.request || '');
        li.dataset.role = req.role || '';
        li.dataset.timestamp = req.timestamp || '';
        li.dataset.lastSeen = String(Date.now());
        li.className = 'request-item ' + (req.role || '');

        const p = li.querySelector('p');
        if (p) p.textContent = req.request || '';
        const meta = li.querySelector('.meta');
        if (meta) {
          const spans = meta.querySelectorAll('span');
          if (spans[0]) spans[0].textContent = `Room: ${req.room || '—'}`;
          if (spans[1]) spans[1].textContent = `For: ${(req.role || '').toUpperCase()}`;
        }
      } else {
        // Create new
        li = document.createElement('li');
        li.id = req.id;
        li.className = 'request-item ' + (req.role || '');
        li.dataset.id = req.id || '';
        li.dataset.room = req.room || '';
        li.dataset.request = normalizeText(req.request || '');
        li.dataset.role = req.role || '';
        li.dataset.timestamp = req.timestamp || '';
        li.dataset.lastSeen = String(Date.now());
        li.innerHTML = buildRequestHTML(req);
        document.getElementById('requests-list').appendChild(li);
      }

      // If server provided a status, trust it and pin locally
      if (req.status) {
        const s = (req.status || 'new').toLowerCase();
        setStatusFor(req.id, req.room, req.request, s);
        li.dataset.localStatus = s;
        delete li.dataset.pendingSync;
      }

      applyLocalStatusToItem(li);
    }

    function addRequestToDashboard(data) {
      upsertRequestItem(data);
      updateAllTimersAndColors();
    }

    // --- Socket events ---
    socket.on('new_request', function(data) {
      addRequestToDashboard(data);
      playNotificationSound();
    });

    socket.on('request_updated', function(data) {
      const item = document.getElementById(data.id || '');
      if (item) {
        item.classList.remove('cna');
        item.classList.add('nurse');
        const roleSpan = item.querySelector('.role-span');
        if (roleSpan) roleSpan.textContent = 'For: NURSE';
        const deferBtn = item.querySelector('.defer-btn');
        if (deferBtn) deferBtn.remove();
        updateAllTimersAndColors();
      }
    });

    socket.on('remove_request', function(data) {
      let el = null;
      if (data.id) el = document.getElementById(data.id);
      if (!el && (data.request || data.room)) {
        const items = document.querySelectorAll('#requests-list .request-item');
        el = Array.from(items).find(li => {
          const sameText = data.request ? (li.dataset.request || '') === normalizeText(data.request) : true;
          const sameRoom = data.room ? (li.dataset.room || '') === data.room : true;
          return sameText && sameRoom;
        });
      }
      if (el) {
        el.style.opacity = '0';
        setTimeout(() => el.remove(), 300);
      }
    });

    socket.on('request_status', function(data) {
      const id = data?.id;
      const st = (data?.status || '').toLowerCase();
      if (!id || !st) return;

      const li = document.getElementById(id);
      const room = li ? li.dataset.room : '';
      const text = li ? li.dataset.request : '';
      setStatusFor(id, room, text, st);

      if (li) {
        li.dataset.localStatus = st;      // pin to DOM
        delete li.dataset.pendingSync;
        applyLocalStatusToItem(li);
      }
    });

    // --- Click handlers ---
    document.addEventListener('DOMContentLoaded', function() {
      const list = document.getElementById('requests-list');
      if (!list) return;

      list.addEventListener('click', function(e) {
        const btn = e.target;
        if (btn.tagName !== 'BUTTON') return;

        const item = btn.closest('.request-item');
        if (!item) return;

        const requestId   = item.dataset.id || '';
        const roomNumber  = item.dataset.room || '';
        const dashRoom    = item.dataset.room || '';
        const nurseName   = NurseName || '';
        const reqText     = item.dataset.request || '';

        function sendAck(status, dashMessage) {
          // Save under both ID and composite key
          setStatusFor(requestId, roomNumber, reqText, status);
          // Pin to DOM so polls cannot wipe it
          item.dataset.localStatus = status;
          delete item.dataset.pendingSync;

          applyLocalStatusToItem(item);

          socket.emit('acknowledge_request', {
            request_id: requestId,
            room_number: roomNumber,
            nurse_name: nurseName,
            status: status,
            room: dashRoom,
            message: dashMessage
          });
        }

        if (btn.classList.contains('ack-button')) {
          btn.disabled = true;
          sendAck('ack', "✅ Request acknowledged.");
        } else if (btn.classList.contains('omw-button')) {
          btn.disabled = true;
          const ack = item.querySelector('.ack-button'); if (ack) ack.disabled = true;
          sendAck('omw', "✅ On my way.");
        } else if (btn.classList.contains('asap-button')) {
          btn.disabled = true;
          const ack = item.querySelector('.ack-button'); if (ack) ack.disabled = true;
          const omw = item.querySelector('.omw-button'); if (omw) omw.disabled = true;
          sendAck('asap', "In another room — will be there ASAP.");
        } else if (btn.classList.contains('defer-btn')) {
          socket.emit('defer_request', { id: requestId });
        } else if (btn.classList.contains('complete-btn')) {
          socket.emit('complete_request', {
            request_id: requestId,
            room_number: roomNumber,
            nurse_name: nurseName,
            request_text: reqText
          });
          btn.disabled = true;
          // Pin completed locally to prevent UI re-enable
          item.dataset.localStatus = 'completed';
          delete item.dataset.pendingSync;
          applyLocalStatusToItem(item);
        }
      });

      // Manual refresh
      const btnRefresh = document.getElementById('manual-refresh');
      if (btnRefresh) btnRefresh.addEventListener('click', pollActiveRequests);

      // Start timers + polling
      updateAllTimersAndColors();
      setInterval(updateAllTimersAndColors, 60000);
      setTimeout(pollActiveRequests, 500);
      setInterval(pollActiveRequests, 20000);

      // Periodic cleanup for stale rows
      setInterval(cleanupStaleRows, 60 * 1000);
    });

    // Stable polling: update in place, append new, remove missing, reconcile new IDs
    function pollActiveRequests() {
      const params = new URLSearchParams();
      if (NurseContext && NurseName) {
        params.set('staff_name', NurseName);
        if (NurseShift) params.set('shift', NurseShift);
        params.set('scope', NurseScope || 'mine');
      } else {
        params.set('scope', 'all');
      }

      fetch(`/api/active_requests?${params.toString()}`)
        .then(r => r.ok ? r.json() : Promise.reject())
        .then(json => {
          const incoming = (json && json.active_requests) ? json.active_requests : [];

          // newest first for consistent visual order
          incoming.sort((a, b) => (new Date(b.timestamp||0)) - (new Date(a.timestamp||0)));

          // Build incoming id set and composite-key map
          const incomingIds = new Set();
          const incomingByKey = new Map(); // `${room}::${text}` -> item
          incoming.forEach(it => {
            if (!it.id) it.id = 'key:' + makeCompositeKey(it.room, it.request);
            incomingIds.add(it.id);
            incomingByKey.set(makeCompositeKey(it.room, it.request), it);
          });

          const list = document.getElementById('requests-list');

          // Reconcile existing DOM items against incoming
          Array.from(list.querySelectorAll('.request-item')).forEach(li => {
            const id   = li.dataset.id || '';
            const room = li.dataset.room || '';
            const text = li.dataset.request || '';
            const key  = makeCompositeKey(room, text);

            const stillById  = id && incomingIds.has(id);
            const stillByKey = incomingByKey.has(key);

            if (stillById || stillByKey) {
              li.dataset.lastSeen = String(Date.now());
              delete li.dataset.pendingSync;
            }

            // Same request, new id -> update node id, carry status forward
            if (!stillById && stillByKey) {
              const newer = incomingByKey.get(key);
              if (newer && newer.id) {
                const oldStatus = li.dataset.localStatus || getStatusFor(id, room, text);
                li.id = newer.id;
                li.dataset.id = newer.id;
                li.dataset.lastSeen = String(Date.now());
                if (oldStatus) {
                  setStatusFor(newer.id, room, text, oldStatus);
                  li.dataset.localStatus = oldStatus; // DOM-pinned survives
                }
              }
            } else if (!stillById && !stillByKey && id) {
              // If clinician already interacted, DO NOT remove on poll—mark pending
              if (li.dataset.localStatus) {
                li.dataset.pendingSync = '1';
                const badge = li.querySelector('.status-badge');
                if (badge) { badge.textContent = 'Pending sync'; badge.style.display = 'inline-flex'; }
                li.classList.add('status-warn');
              } else {
                // OK to remove quietly (never touched by user)
                li.style.opacity = '0';
                setTimeout(() => li.remove(), 300);
              }
            }
          });

          // Upsert incoming items (append new; update existing in place)
          incoming.forEach(upsertRequestItem);

          updateAllTimersAndColors();

          const ts = new Date();
          const el = document.getElementById('last-refresh');
          if (el) el.textContent = `Updated ${ts.toLocaleTimeString()}`;
        })
        .catch(() => {
          const el = document.getElementById('last-refresh');
          if (el) el.textContent = `Update failed`;
        });
    }

    // Cleanup for truly stale items
    function cleanupStaleRows() {
      const now = Date.now();
      const STALE_MS_UNTOUCHED = 5 * 60 * 1000;   // 5 minutes
      const STALE_MS_TOUCHED   = 60 * 60 * 1000;  // 60 minutes

      document.querySelectorAll('#requests-list .request-item').forEach(li => {
        const lastSeen = Number(li.dataset.lastSeen || 0);
        const local = !!li.dataset.localStatus;
        if (!lastSeen) return;

        if (!local && now - lastSeen > STALE_MS_UNTOUCHED) {
          li.style.opacity = '0';
          setTimeout(() => li.remove(), 300);
        } else if (local && now - lastSeen > STALE_MS_TOUCHED) {
          li.style.opacity = '0';
          setTimeout(() => li.remove(), 300);
        }
      });
    }
  </script>
</body>
</html>
